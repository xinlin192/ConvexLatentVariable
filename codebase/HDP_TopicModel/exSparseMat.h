/*###############################################################
## MODULE: exSparseMat.h
## VERSION: 2.0 
## SINCE: 2014-07-24
## AUTHOR: Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##     Header file for Extensible Sparse matrix  
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "string"
#include "vector"
#include "assert.h"
#include "math.h"

using namespace std;
/* Global variables */
const double DUMMY_PENALTY_RATE = 1000.0;
const double TRIM_THRESHOLD = 10e-5;
const double INFINITY = 10e300;

/* Definition of Data structure for Extensible Sparse Matrix (Esmat*) */
typedef struct {
        int nRows; int nCols;
        vector< pair<int, double> >  val;
} Esmat ;

/* Powerful function pointers and definition of instantiated operators */
typedef double (* Operation) (double, double); 
double min (double a, double b) { return a < b ? a : b; }
double max (double a, double b) { return a > b ? a : b; }
double sum (double a, double b) { return a + b; }
double diff (double a, double b) { return a - b; } // non-symmetric 
double times (double a, double b) { return a * b; }
double power2 (double val, double counter) 
    { return counter + val * val; } // non-symmetric
double dummy_penalty (double val, double counter) 
    { return counter + DUMMY_PENALTY_RATE * (1 - val); }
double count (double value, double counter) { 
    // note that for this "count" function, two input is not symmetric
    if (fabs(value) > TRIM_THRESHOLD) counter += 1.0;
    return counter; 
}

/* Prototype for fundamental functions, typically computational frameworks*/
double esmat_unary_operate (Esmat *A, Operation opt);
void esmat_bin_operate (Esmat* A, Esmat* B, Esmat* dest, Operation opt);
void esmat_operate_col (Esmat* A, Esmat* dest, Operation opt);
void esmat_operate_row (Esmat* A, Esmat* dest, Operation opt);

/* Allocation and De-allocation */
Esmat* esmat_init (int nRows, int nCols);
Esmat* esmat_init (Esmat * A);
Esmat* esmat_init ();
void esmat_init_all (vector<Esmat*>* src);
void esmat_free (Esmat* src);
void esmat_free_all (vector<Esmat*> src);
/* Rearrange one esmat */
void esmat_align (Esmat* mat) {
/* submat and merge */
void esmat_submat_row (int start_index, int end_index, Esmat* mat, Esmat* submat);
void esmat_submat_row (Esmat* mat, vector<Esmat*> submats, vector<int>* word_lookup, vector< vector<int> >* voc_lookup);
void esmat_merge_row (Esmat* submat, int start_index, int end_index, Esmat* mat);
void esmat_merge_row (Esmat* submat, vector<int>* sub_voc_lookup, Esmat* mat);
/* frobenius product and norm */
double esmat_fdot (Esmat* A, Esmat* B);
double esmat_sum (Esmat* A);
double esmat_fnorm (Esmat* A);
/* scalar multiplication */
void esmat_scalar_mult (double scalar, Esmat* A);
void esmat_scalar_mult (double scalar, Esmat* A, Esmat* dest);
/* Auxiliary functions */
bool esmat_isValid (Esmat* A, Esmat* B, int mode);
string esmat_toString (Esmat* A);
void esmat_copy (Esmat* A, Esmat* D);
void esmat_trim (Esmat* A);

/* Sum of all element on one matrix */
double esmat_sum (Esmat* A) 
{ return esmat_unary_operate (A, sum); }
/* Frobenius norm of one extensible sparse matrices */
double esmat_fnorm (Esmat* A) 
{ return esmat_unary_operate (A, power2); }
/* Compute dummy term */
double esmat_compute_dummy (Esmat* A) 
{ return esmat_unary_operate (A, dummy_penalty); }

/* Add and Subtract two extensible sparse matrices */
void esmat_add (Esmat* A, Esmat* B, Esmat* dest) 
{ esmat_bin_operate (A, B, dest, sum); }
void esmat_sub (Esmat* A, Esmat* B, Esmat* dest) 
{ esmat_bin_operate (A, B, dest, diff); }

/* min, max and sum over column elements */
void esmat_min_col (Esmat* A, Esmat* dest) 
{ esmat_operate_col (A, dest, min, INFINITY); }
void esmat_max_col (Esmat* A, Esmat* dest) 
{ esmat_operate_col (A, dest, max, -INFINITY); }
void esmat_sum_col (Esmat* A, Esmat* dest) 
{ esmat_operate_col (A, dest, sum, 0.0); }

/* min, max and sum over row elements */
void esmat_min_row (Esmat* A, Esmat* dest) 
{ esmat_operate_row (A, dest, min, INFINITY); }
void esmat_max_row (Esmat* A, Esmat* dest) 
{ esmat_operate_row (A, dest, max, -INFINITY); }
void esmat_sum_row (Esmat* A, Esmat* dest) 
{ esmat_operate_row (A, dest, sum, 0.0); }

