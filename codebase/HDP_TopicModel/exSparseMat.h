/*###############################################################
## MODULE: exSparseMat.h
## VERSION: 1.0 
## SINCE: 2014-07-24
## AUTHOR: Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##     Header file for Extensible Sparse matrix  
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include <string>

typedef struct {
        int nRows;
        int nCols;
        vector< pair<int, double> > val;
} Esmat;

/* Initialize one extensible sparse matrix with all zero entries */
Esmat esmat_init (int nRows, int nCols) {

    Esmat freshman = new Esmat ();
    freshman.nRows = nRows;
    freshman.nCols = nCols;
    freshman.val = new vector< pair<int, double> > ();

    return freshman;
}

void esmat_free (Esmat src) {

    delete src.val;
    delete Esmat;

}

/* Add two extensible sparse matrices */
void esmat_add (Esmat A, Esmat B, Esmat dest) {
    
    assert (esmat_isValid (A, B, 1));
    dest.nCols = A.nCols;
    dest.nRows = A.nRows;
    dest.val.clear();

    int i = 0, j = 0;
    int indexA, indexB;
    int sizeA = A.val.size();
    int sizeB = B.val.size();

    while (i < sizeA && j < sizeB) {
        indexA = A.val[i].first;
        indexB = B.val[i].first;

        if (indexA < indexB) {
            dest.val.push_back(make_pair(indexA, A.val[i].second))
            ++ i; 
        } else if (indexA > indexB) {
            dest.val.push_back(make_pair(indexB, B.val[i].second))
            ++ j;
        } else { // equality
            value = A.val[i].second + B.val[i].second;
            dest.val.push_back(make_pair(indexA, value))
            ++i; ++j;
        }
    }

}

/* Subtract two extensible sparse matrices */
void esmat_sub (Esmat A, Esmat B, Esmat dest) {
    
    assert (esmat_isValid (A, B, 1));
    dest.nCols = A.nCols;
    dest.nRows = A.nRows;
    dest.val.clear();

    int i = 0, j = 0;
    int indexA, indexB;
    int sizeA = A.val.size();
    int sizeB = B.val.size();

    while (i < sizeA && j < sizeB) {
        indexA = A.val[i].first;
        indexB = B.val[i].first;

        if (indexA < indexB) {
            dest.val.push_back(make_pair(indexA, A.val[i].second))
            ++ i; 
        } else if (indexA > indexB) {
            dest.val.push_back(make_pair(indexB, B.val[i].second))
            ++ j;
        } else { // equality
            value = A.val[i].second - B.val[i].second;
            dest.val.push_back(make_pair(indexA, value))
            ++i; ++j;
        }
    }
}

/* Frobenius norm of one extensible sparse matrices */
double esmat_fnorm (Esmat A) {

    double fnorm = 0.0;
    int sizeA = A.val.size();

    for (int i = 0; i < sizeA; i++) {
        fnorm += A.val[i].second * 2;
    }

    return fnorm;
}

/* scalar times a esmat and store on input matrix*/
void esmat_scalar_mult (double scalar, Esmat A) {

    int sizeA = A.val.size();
    int capacity = A.nRows * A.nCols;

    for (int i = 0; i < sizeA; i ++) {
        assert (A.val[i].first < capacity);
        A.val[i].second *= scalar; 
    }

}

/* scalar times a esmat */
void esmat_scalar_mult (double scalar, Esmat A, Esmat dest) {

    assert (esmat_isValid (A, dest, 1));

    dest.val.clear();

    for (int i = 0; i < A.val.size(); i ++) {
        // insert multiplied value to the same position
        dest.val.push_back(make_pair(A.val[i].first, scalar*A.val[i].second)); 
    }

}

/* Check validity (dim alignment) of input esmat 
 *  mode:
 *    1 - same dim alignment
 *    2 - product alignment
 * */
esmat_isValid (Esmat A, Esmat B, int mode) {

    bool success = false;

    if (mode == 1) {
        if (A.nRows == B.nRows && A.nCols == B.nCols) 
            success = true;
    } else if (mode == 2) {
        if (A.nCols == B.nRows) 
            success = true;
    }

    return success;
}

/* frobenius product */
esmat_fdot (Esmat A, Esmat B) {

    assert (esmat_isValid (A, B, 1));

    int i = 0, j = 0;
    int indexA, indexB;
    int sizeA = A.val.size();
    int sizeB = B.val.size();
    double result = 0.0;

    while (i < sizeA && j < sizeB) {
        indexA = A.val[i].first;
        indexB = B.val[i].first;

        if (indexA < indexB) {
            ++ i; 
        } else if (indexA > indexB) {
            ++ j;
        } else { // equality
            result += A.val[i].second * B.val[j].second;
            ++i; ++j;
        }
    }

    return result;
}

void esmat_sum_row (double ** src, double * dest, int nRows, int nCols) {
    
    for (int i = 0; i < nRows; i ++) {
        double sum = 0.0;
        for (int j = 0; j < nCols; j ++) {
            sum += src[i][j];
        }
        dest[i] = sum;
    }

}

void mat_sum_col(double ** src, double * dest, int nRows, int nCols) {
    
    for (int j = 0;j < nCols; j ++)
	    dest[j] = 0.0;

    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nCols; j ++) {
            dest[j] += src[i][j];
        }
    }
}

string esmat_toString (Esmat A) {

    assert (A.nRows > 0);
    assert (A.nCols > 0);

    string idx_val_separator = ":";
    string field_seperator = ",";
    string line_separator = "\n";

    vector<string> allStrings = new vector<string> (A.nRows, NULL) ;
    string str = "";

    int sizeA = A.val.size();
    for (int i = 0; i < sizeA; i ++) {
        int overall_idx = A.val[i].first;
        // column major data structure
        int col_idx = overall_idx / A.nRows;
        int row_idx = overall_idx % A.nRows;
        assert (col_idx < A.nCols);
        assert (row_idx < A.nRows);
        // generate newly added string
        string temp = col_idx + idx_val_separator + A.val[i].second;
        // row major string representation
        if (allStrings[row_idx] == NULL) {
            allStrings[row_idx] = "" + temp;
        } else {
            allStrings[row_idx] += field_seperator + temp;
        }
    }

    for (int i = 0; i < nRows; i ++) {
        str += allStrings[i] + line_separator;
    }

    return str;
}

/* copy content of Esmat A to Esmat D */
void esmat_copy (Esmat A, Esmat D) {

    D.nRows = A.nRows;
    D.nCols = A.nCols;
    D.val.clear();

    int sizeA = A.val.size();
    for (int i = 0; i < sizeA; i ++) {
        D.val.push_back(make_pair (A.val[i].first, A.val[i].second));
    }
}

/* regularization for penalizing global topics */
void mat_max_col (double ** src, double ** dest, int nRows, int nCols) {

    // we assume that the given dest is all-zero mat
    for (int j = 0; j < nCols; j ++) {
        int max_index = -1;
        double max_value = -INF;
        for (int i = 0; i < nRows; i ++) {
            if (src[i][j] > max_value) {
                max_index = i;
                max_value = src[i][j];
            }
	    dest[i][j] = 0;
        }
        dest[max_index][j] = 1;
    }
}

/* regularization for penalizing local topics */
mat_count_row () {


}

/* regularization for penalizing number of vocabularies used by topics */
mat_nonzero_index_col {

}

void mat_min_row (double ** src, double ** dest, int nRows, int nCols) {

    for (int i = 0; i < nRows; i ++) {
        int min_index = -1;
        double min_value = INF;
        for (int j = 0; j < nCols; j ++) {
            if (src[i][j] < min_value) {
                min_index = j;
                min_value = src[i][j];
            }
            dest[i][j] = 0;
        }
        assert (min_index >= 0);
        dest[i][min_index] = 1;
    }

}

void esmat_trim (Esmat A) {
	
    int sizeA = A.val.size();

	for (int i = 0; i < sizeA; i ++) {
        double value = A.val[i].second;
        if ( fabs(value) < 1e-5 ) {
            // remove this index:value pair
            A.val.erase(A.val.begin()+i);
            -- i;
            -- sizeA;
        }
	}

}
