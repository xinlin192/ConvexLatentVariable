/*###############################################################
## MODULE: HDP.h
## VERSION: 2.0 
## SINCE 2014-06-14
## AUTHOR Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##     This file includes problem-specific data structure and
## utility function.
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include<iostream>
#include<fstream>
#include<stdlib.h>
#include<vector>
#include<map>
#include<set>
#include<algorithm>
#include <cmath>    
#include <cassert>

#include "../util.h"

using namespace std;

void voc_list_read (string fname, vector<string>* vocList) {
   	ifstream fin(fname);

	string line;
	while (!fin.eof()) {
        fin >> line;
		if ( fin.eof() ) break;
        vocList->push_back (line);
	}
	fin.close(); 
}

void voc_list_print (vector<string>* vocList) {
    int nVoc = vocList->size();
    for (int v = 0; v < nVoc; v ++) {
        cout << (*vocList)[v] << endl;
    }
}

void document_list_read (string fname, vector< pair<int,int> >* doc_lookup, vector<int>* word_lookup) {

   	ifstream fin(fname);

	string line;
    int doc_index_begin = 0;
    int doc_index_end = 0;
    int d = 0; w = 0;
	while (!fin.eof()) {
        fin >> line;
		if ( fin.eof() ) break;
        // process new document
        doc_index_begin = w;
        // TODO: split the string to several field (delimiter: whitespace) 
        for () {
            // for each word, split voc_index and frequency by ":"
            int voc_index = ; 
            int frequency = ;
            // push to word_lookup table
            word_lookup->push_back(voc_index);
            ++ w;
        }
        doc_index_end = w;
        doc_lookup->push_back(make_pair(doc_index_begin, doc_index_end));
        ++ d;
	}
	fin.close(); 
} 

class Instance{
	
	public:
	int id;
	int label;
	vector<pair<int,double> > fea;
	Instance(int _id){
		id = _id;
		_x_sq = -1.0;
	}
	
	double x_sq(){
		
		// Pre-calculated
		if( _x_sq != -1.0 ){
			return _x_sq;
		}
		
		// Calculate and Cache
		_x_sq = 0.0;
		double tmp;
		for(int i=0;i<fea.size();i++){
			tmp = fea[i].second;
			_x_sq += tmp*tmp;
		}

		return _x_sq;
	}

	private:
	double _x_sq;
};

class ScoreComparator{
	
	private:
	vector<double>* score_vec;

	public:
	ScoreComparator(vector<double>* vec){
		score_vec = vec;
	}

	bool operator() (int i,int j) { 
		return score_vec->at(i) < score_vec->at(j); 
	}
};


void read2D(char* fname, vector<Instance*>& data){
	
	ifstream fin(fname);
	int tmp;
	double x,y;
	int id=0;
	while(!fin.eof()){
		
		fin >> tmp >> x >> y;
		if( fin.eof() )break;

		Instance* ins = new Instance(id++);
		ins->fea.push_back(make_pair(1,x));
		ins->fea.push_back(make_pair(2,y));
		
		data.push_back(ins);
	}
	fin.close();
}

void readFixDim(char* fname, vector<Instance*>& data, int D){
	
	ifstream fin(fname);
	int tmp;
	double val;
	int id=0;
	while(!fin.eof()){
		
		fin >> tmp;
		if ( fin.eof() ) break;
		
		Instance* ins = new Instance(id++);
	       	for(int j=0;j<D;j++) {
			fin >> val;
			ins->fea.push_back(make_pair(j+1,val));
		}
		
		data.push_back(ins);
		id++;
	}
	fin.close();
}
